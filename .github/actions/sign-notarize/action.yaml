name: 'Sign and Notarize Binary'
description: 'Code sign and notarize binaries on macOS and Windows'
inputs:
  binary-path:
    description: 'Path to the binary file to sign'
    required: true
  mac-cert-id:
    description: 'The Apple certificate ID (e.g., "A1B2C3D4E5")'
    required: false
  mac-cert-base64:
    description: 'Base64-encoded p12 signing certificate'
    required: false
  mac-cert-passwd:
    description: 'Password for the p12 certificate'
    required: false
  mac-api-key-base64:
    description: 'Base64-encoded content of the API key file for notarization'
    required: false
  mac-api-key-id:
    description: 'Key ID from App Store Connect'
    required: false
  mac-api-key-issuer-id:
    description: 'Issuer ID from App Store Connect'
    required: false
  windows-pfx-base64:
    description: 'Base64 encoded Windows PFX certificate'
    required: false
  windows-pfx-password:
    description: 'Password for the Windows PFX certificate'
    required: false

runs:
  using: 'composite'
  steps:
    - name: Import Code-Signing Certificates (macOS)
      if: runner.os == 'macOS' && inputs.mac-cert-base64 != ''
      uses: apple-actions/import-codesign-certs@b610f78488812c1e56b20e6df63ec42d833f2d14 # v6.0.0
      with:
        p12-file-base64: ${{ inputs.mac-cert-base64 }}
        p12-password: ${{ inputs.mac-cert-passwd }}
    
    - name: Sign Binary (macOS)
      if: runner.os == 'macOS' && inputs.mac-cert-base64 != ''
      shell: bash
      env:
        BINARY_PATH: ${{ inputs.binary-path }}
        CERT_ID: ${{ inputs.mac-cert-id }}
      run: |
        echo "Signing ${BINARY_PATH}"
        codesign --remove-signature ${BINARY_PATH} || true
        codesign -s "${CERT_ID}" --timestamp --options runtime -v "${BINARY_PATH}"
        echo "Signed ${BINARY_PATH} with ${CERT_ID}"
    
    - name: Notarize Binary (macOS)
      if: runner.os == 'macOS' && inputs.mac-api-key-base64 != ''
      shell: bash
      env:
        BINARY_PATH: ${{ inputs.binary-path }}
        API_KEY_BASE64: ${{ inputs.mac-api-key-base64 }}
        API_KEY_ID: ${{ inputs.mac-api-key-id }}
        API_KEY_ISSUER_ID: ${{ inputs.mac-api-key-issuer-id }}
        API_KEY_FILE: ${{ format('AuthKey_{0}.p8', inputs.mac-api-key-id) }}
      run: |
        # Decode API Key
        echo "${API_KEY_BASE64}" | base64 -d > "${GITHUB_WORKSPACE}/${API_KEY_FILE}"

        # Ensure cleanup on exit
        trap 'rm -f "${BINARY_PATH}.zip" "${GITHUB_WORKSPACE}/${API_KEY_FILE}"' EXIT

        # Create zip for notarization
        /usr/bin/ditto -c -k ${BINARY_PATH} ${BINARY_PATH}.zip

        # Submit to Apple
        echo "Submitting to Apple Notary Service..."
        xcrun notarytool submit -f json \
          --key-id "${API_KEY_ID}" \
          --issuer "${API_KEY_ISSUER_ID}" \
          --key "${API_KEY_FILE}" \
          --wait ${BINARY_PATH}.zip 2>&1 | tee /tmp/notarization_info.json

        status=$(jq -r .status </tmp/notarization_info.json)
        id=$(jq -r .id </tmp/notarization_info.json)
        echo "Notarization status=${status} id=${id}"

        # Check logic
        if [ "$status" != "Accepted" ]; then
            xcrun notarytool log "${id}" -f json \
              --key-id "${API_KEY_ID}" \
              --issuer "${API_KEY_ISSUER_ID}" \
              --key "${API_KEY_FILE}" >/tmp/notarization_log.json
            issues=$(jq -r .issues </tmp/notarization_log.json)
            printf "There are issues with the notarization (${issues})\n"
            printf "=== Log output === \n$(cat /tmp/notarization_log.json)\n"
            exit 1
        fi

        # Staple
        xcrun stapler staple "$BINARY_PATH"

    - name: Sign (Windows)
      if: runner.os == 'Windows' && inputs.windows-pfx-base64 != ''
      shell: pwsh
      env:
        BINARY_PATH: ${{ inputs.binary-path }}
        WINDOWS_PFX_BASE64: ${{ inputs.windows-pfx-base64 }}
        WINDOWS_PFX_PASSWORD: ${{ inputs.windows-pfx-password }}
      run: |
        try {
          # Decode certificate
          New-Item -ItemType directory -Path certificate
          Set-Content -Path certificate\certificate.txt -Value $env:WINDOWS_PFX_BASE64
          certutil -decode certificate\certificate.txt certificate\certificate.pfx
          
          # Sign
          signtool sign `
            /f certificate\certificate.pfx `
            /p $env:WINDOWS_PFX_PASSWORD `
            /tr http://timestamp.digicert.com `
            /td sha256 `
            /fd sha256 `
            $env:BINARY_PATH
        } finally {
          # Cleanup
          Remove-Item -Recurse -Force certificate -ErrorAction Ignore
        }
